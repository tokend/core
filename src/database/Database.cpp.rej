diff a/src/database/Database.cpp b/src/database/Database.cpp	(rejected hunks)
@@ -3,43 +3,46 @@
 // of this distribution or at http://www.apache.org/licenses/LICENSE-2.0
 
 #include "database/Database.h"
-#include "overlay/StellarXDR.h"
+#include "crypto/Hex.h"
+#include "database/DatabaseConnectionString.h"
+#include "database/DatabaseTypeSpecificOperation.h"
 #include "main/Application.h"
 #include "main/Config.h"
-#include "util/Logging.h"
-#include "util/make_unique.h"
-#include "util/types.h"
+#include "overlay/StellarXDR.h"
 #include "util/GlobalChecks.h"
+#include "util/Logging.h"
 #include "util/Timer.h"
-#include "crypto/Hex.h"
+#include "util/types.h"
 
-#include "ledger/AccountFrame.h"
-#include "ledger/OfferFrame.h"
-#include "ledger/TrustFrame.h"
-#include "ledger/DataFrame.h"
-#include "overlay/OverlayManager.h"
-#include "overlay/BanManager.h"
-#include "main/PersistentState.h"
+#include "bucket/BucketManager.h"
+#include "herder/HerderPersistence.h"
+#include "herder/Upgrades.h"
+#include "history/HistoryManager.h"
+#include "ledger/LedgerHeaderUtils.h"
+#include "ledger/LedgerTxn.h"
 #include "main/ExternalQueue.h"
-#include "ledger/LedgerHeaderFrame.h"
+#include "main/PersistentState.h"
+#include "overlay/BanManager.h"
+#include "overlay/OverlayManager.h"
+#include "overlay/PeerManager.h"
 #include "transactions/TransactionFrame.h"
-#include "bucket/BucketManager.h"
-#include "herder/Herder.h"
 
+#include "medida/counter.h"
 #include "medida/metrics_registry.h"
 #include "medida/timer.h"
-#include "medida/counter.h"
 
-#include <stdexcept>
-#include <vector>
+#include <lib/soci/src/backends/sqlite3/soci-sqlite3.h>
+#ifdef USE_POSTGRES
+#include <lib/soci/src/backends/postgresql/soci-postgresql.h>
+#endif
 #include <sstream>
+#include <stdexcept>
 #include <thread>
+#include <vector>
 
-extern "C" void register_factory_sqlite3();
-
-#ifdef USE_POSTGRES
-extern "C" void register_factory_postgresql();
-#endif
+extern "C" int
+sqlite3_carray_init(sqlite_api::sqlite3* db, char** pzErrMsg,
+                    const sqlite_api::sqlite3_api_routines* pApi);
 
 // NOTE: soci will just crash and not throw
 //  if you misname a column in a query. yay!
@@ -52,13 +55,53 @@ using namespace std;
 
 bool Database::gDriversRegistered = false;
 
-static unsigned long const SCHEMA_VERSION = 4;
+static unsigned long const SCHEMA_VERSION = 9;
+
+// These should always match our compiled version precisely, since we are
+// using a bundled version to get access to carray(). But in case someone
+// overrides that or our build configuration changes, it's nicer to get a
+// more-precise version-mismatch error message than a runtime crash due
+// to using SQLite features that aren't supported on an old version.
+static int const MIN_SQLITE_MAJOR_VERSION = 3;
+static int const MIN_SQLITE_MINOR_VERSION = 26;
+static int const MIN_SQLITE_VERSION =
+    (1000000 * MIN_SQLITE_MAJOR_VERSION) + (1000 * MIN_SQLITE_MINOR_VERSION);
+
+// PostgreSQL pre-10.0 actually used its "minor number" as a major one
+// (meaning: 9.4 and 9.5 were considered different major releases, with
+// compatibility differences and so forth). After 10.0 they started doing
+// what everyone else does, where 10.0 and 10.1 were only "minor". Either
+// way though, we have a minimum minor version.
+static int const MIN_POSTGRESQL_MAJOR_VERSION = 9;
+static int const MIN_POSTGRESQL_MINOR_VERSION = 5;
+static int const MIN_POSTGRESQL_VERSION =
+    (10000 * MIN_POSTGRESQL_MAJOR_VERSION) +
+    (100 * MIN_POSTGRESQL_MINOR_VERSION);
 
-static void
-setSerializable(soci::session& sess)
+#ifdef USE_POSTGRES
+static std::string
+badPgVersion(int vers)
 {
-    sess << "SET SESSION CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL "
-            "SERIALIZABLE";
+    std::ostringstream msg;
+    int maj = (vers / 10000);
+    int min = (vers - (maj * 10000)) / 100;
+    msg << "PostgreSQL version " << maj << '.' << min
+        << " is too old, must use at least " << MIN_POSTGRESQL_MAJOR_VERSION
+        << '.' << MIN_POSTGRESQL_MINOR_VERSION;
+    return msg.str();
+}
+#endif
+
+static std::string
+badSqliteVersion(int vers)
+{
+    std::ostringstream msg;
+    int maj = (vers / 1000000);
+    int min = (vers - (maj * 1000000)) / 1000;
+    msg << "SQLite version " << maj << '.' << min
+        << " is too old, must use at least " << MIN_SQLITE_MAJOR_VERSION << '.'
+        << MIN_SQLITE_MINOR_VERSION;
+    return msg.str();
 }
 
 void
@@ -74,32 +117,68 @@ Database::registerDrivers()
     }
 }
 
+// Helper class that confirms that we're running on a new-enough version
+// of each database type and tweaks some per-backend settings.
+class DatabaseConfigureSessionOp : public DatabaseTypeSpecificOperation<void>
+{
+    soci::session& mSession;
+
+  public:
+    DatabaseConfigureSessionOp(soci::session& sess) : mSession(sess)
+    {
+    }
+    void
+    doSqliteSpecificOperation(soci::sqlite3_session_backend* sq) override
+    {
+        int vers = sqlite_api::sqlite3_libversion_number();
+        if (vers < MIN_SQLITE_VERSION)
+        {
+            throw std::runtime_error(badSqliteVersion(vers));
+        }
+
+        mSession << "PRAGMA journal_mode = WAL";
+        // busy_timeout gives room for external processes
+        // that may lock the database for some time
+        mSession << "PRAGMA busy_timeout = 10000";
+
+        // Register the sqlite carray() extension we use for bulk operations.
+        sqlite3_carray_init(sq->conn_, nullptr, nullptr);
+    }
+#ifdef USE_POSTGRES
+    void
+    doPostgresSpecificOperation(soci::postgresql_session_backend* pg) override
+    {
+        int vers = PQserverVersion(pg->conn_);
+        if (vers < MIN_POSTGRESQL_VERSION)
+        {
+            throw std::runtime_error(badPgVersion(vers));
+        }
+        mSession
+            << "SET SESSION CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL "
+               "SERIALIZABLE";
+    }
+#endif
+};
+
 Database::Database(Application& app)
     : mApp(app)
     , mQueryMeter(
           app.getMetrics().NewMeter({"database", "query", "exec"}, "query"))
     , mStatementsSize(
           app.getMetrics().NewCounter({"database", "memory", "statements"}))
-    , mEntryCache(4096)
     , mExcludedQueryTime(0)
     , mExcludedTotalTime(0)
     , mLastIdleQueryTime(0)
     , mLastIdleTotalTime(app.getClock().now())
 {
     registerDrivers();
-    CLOG(INFO, "Database") << "Connecting to: " << app.getConfig().DATABASE;
-    mSession.open(app.getConfig().DATABASE);
-    if (isSqlite())
-    {
-        mSession << "PRAGMA journal_mode = WAL";
-        // busy_timeout gives room for external processes
-        // that may lock the database for some time
-        mSession << "PRAGMA busy_timeout = 10000";
-    }
-    else
-    {
-        setSerializable(mSession);
-    }
+
+    CLOG(INFO, "Database") << "Connecting to: "
+                           << removePasswordFromConnectionString(
+                                  app.getConfig().DATABASE.value);
+    mSession.open(app.getConfig().DATABASE.value);
+    DatabaseConfigureSessionOp op(mSession);
+    doDatabaseTypeSpecificOperation(op);
 }
 
 void
@@ -107,24 +186,51 @@ Database::applySchemaUpgrade(unsigned long vers)
 {
     clearPreparedStatementCache();
 
+    soci::transaction tx(mSession);
     switch (vers)
     {
-    case 2:
-        Herder::dropAll(*this);
+    case 7:
+        Upgrades::dropAll(*this);
+        mSession << "ALTER TABLE accounts ADD buyingliabilities BIGINT "
+                    "CHECK (buyingliabilities >= 0)";
+        mSession << "ALTER TABLE accounts ADD sellingliabilities BIGINT "
+                    "CHECK (sellingliabilities >= 0)";
+        mSession << "ALTER TABLE trustlines ADD buyingliabilities BIGINT "
+                    "CHECK (buyingliabilities >= 0)";
+        mSession << "ALTER TABLE trustlines ADD sellingliabilities BIGINT "
+                    "CHECK (sellingliabilities >= 0)";
         break;
 
-    case 3:
-        DataFrame::dropAll(*this);
+    case 8:
+        mSession << "ALTER TABLE peers RENAME flags TO type";
+        mSession << "UPDATE peers SET type = 2*type";
         break;
-
-    case 4:
-        BanManager::dropAll(*this);
+    case 9:
+        // Update schema for signers
+        mSession << "ALTER TABLE accounts ADD signers TEXT";
+        mApp.getLedgerTxnRoot().writeSignersTableIntoAccountsTable();
+        mSession << "DROP TABLE IF EXISTS signers";
+
+        // Update schema for base-64 encoding
+        mApp.getLedgerTxnRoot().encodeDataNamesBase64();
+        mApp.getLedgerTxnRoot().encodeHomeDomainsBase64();
+
+        // Update schema for simplified offers table
+        mApp.getLedgerTxnRoot().writeOffersIntoSimplifiedOffersTable();
         break;
 
     default:
-        throw std::runtime_error("Unknown DB schema version");
-        break;
+        if (vers <= 6)
+        {
+            throw std::runtime_error(
+                "Database version is too old, must use at least 7");
+        }
+        else
+        {
+            throw std::runtime_error("Unknown DB schema version");
+        }
     }
+    tx.commit();
 }
 
 void
@@ -222,6 +328,16 @@ Database::getUpdateTimer(std::string const& entityName)
         .TimeScope();
 }
 
+medida::TimerContext
+Database::getUpsertTimer(std::string const& entityName)
+{
+    mEntityTypes.insert(entityName);
+    mQueryMeter.Mark();
+    return mApp.getMetrics()
+        .NewTimer({"database", "upsert", entityName})
+        .TimeScope();
+}
+
 void
 Database::setCurrentTransactionReadOnly()
 {
@@ -237,13 +353,14 @@ Database::setCurrentTransactionReadOnly()
 bool
 Database::isSqlite() const
 {
-    return mApp.getConfig().DATABASE.find("sqlite3:") != std::string::npos;
+    return mApp.getConfig().DATABASE.value.find("sqlite3:") !=
+           std::string::npos;
 }
 
 bool
 Database::canUsePool() const
 {
-    return !(mApp.getConfig().DATABASE == ("sqlite3://:memory:"));
+    return !(mApp.getConfig().DATABASE.value == ("sqlite3://:memory:"));
 }
 
 void
@@ -268,17 +385,20 @@ Database::initialize()
 
     // only time this section should be modified is when
     // consolidating changes found in applySchemaUpgrade here
-    AccountFrame::dropAll(*this);
-    OfferFrame::dropAll(*this);
-    TrustFrame::dropAll(*this);
+    mApp.getLedgerTxnRoot().dropAccounts();
+    mApp.getLedgerTxnRoot().dropOffers();
+    mApp.getLedgerTxnRoot().dropTrustLines();
     OverlayManager::dropAll(*this);
     PersistentState::dropAll(*this);
     ExternalQueue::dropAll(*this);
-    LedgerHeaderFrame::dropAll(*this);
+    LedgerHeaderUtils::dropAll(*this);
     TransactionFrame::dropAll(*this);
     HistoryManager::dropAll(*this);
-    BucketManager::dropAll(mApp);
-    putSchemaVersion(1);
+    mApp.getBucketManager().dropAll();
+    HerderPersistence::dropAll(*this);
+    mApp.getLedgerTxnRoot().dropData();
+    BanManager::dropAll(*this);
+    putSchemaVersion(6);
 }
 
 soci::session&
@@ -294,37 +414,30 @@ Database::getPool()
 {
     if (!mPool)
     {
-        std::string const& c = mApp.getConfig().DATABASE;
+        auto const& c = mApp.getConfig().DATABASE;
         if (!canUsePool())
         {
             std::string s("Can't create connection pool to ");
-            s += c;
+            s += removePasswordFromConnectionString(c.value);
             throw std::runtime_error(s);
         }
         size_t n = std::thread::hardware_concurrency();
-        LOG(INFO) << "Establishing " << n << "-entry connection pool to: " << c;
-        mPool = make_unique<soci::connection_pool>(n);
+        LOG(INFO) << "Establishing " << n << "-entry connection pool to: "
+                  << removePasswordFromConnectionString(c.value);
+        mPool = std::make_unique<soci::connection_pool>(n);
         for (size_t i = 0; i < n; ++i)
         {
             LOG(DEBUG) << "Opening pool entry " << i;
             soci::session& sess = mPool->at(i);
-            sess.open(c);
-            if (!isSqlite())
-            {
-                setSerializable(sess);
-            }
+            sess.open(c.value);
+            DatabaseConfigureSessionOp op(sess);
+            doDatabaseTypeSpecificOperation(op);
         }
     }
     assert(mPool);
     return *mPool;
 }
 
-cache::lru_cache<std::string, std::shared_ptr<LedgerEntry const>>&
-Database::getEntryCache()
-{
-    return mEntryCache;
-}
-
 class SQLLogContext : NonCopyable
 {
     std::string mName;
